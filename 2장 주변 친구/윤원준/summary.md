# 2장: 주변 친구 서비스 설계

**설계의 트레이드오프, 면접 질문, 심화 토론**을 위주로 진행하기 위한 정리 자료입니다.

---

## 1. 핵심 트레이드오프 및 설계 논의 (Trade-offs)
설계 선택지 사이의 장단점을 비교하고, 상황에 맞는 최적의 선택을 논의합니다.

### 1.1. 통신 프로토콜 비교: HTTP Polling vs WebSocket
| 특성 | **HTTP Polling** | **WebSocket** |
| :--- | :--- | :--- |
| **통신 방식** | 클라이언트가 주기적으로 요청 (Request-Response) | 양방향 지속 연결 (Full-duplex) |
| **실시간성** | 낮음 (Polling 주기에 의존) | **높음** (서버가 즉시 Push 가능) |
| **서버 부하** | 불필요한 요청(빈 응답)으로 인한 오버헤드 큼 | 연결 유지(Connection)에 대한 메모리 비용 발생 |
| **구현 난이도** | 낮음 (Stateless) | **높음** (Stateful, 연결 관리 필요) |
| **적합성** | 실시간성이 덜 중요한 경우 (예: 알림 목록 갱신) | **위치 공유, 채팅 등 실시간성이 중요한 경우** |

> **논의 포인트**: 
> * "초기 스타트업이라 개발 리소스가 부족하다면?" (Polling으로 시작 후 전환 고려)
> * "배터리 소모와 데이터 사용량을 최소화해야 한다면?" (WebSocket이 헤더 오버헤드가 적어 유리할 수 있음)

### 1.2. 메시지 브로커 선택: Redis Pub/Sub vs Kafka vs RabbitMQ
| 특성 | **Redis Pub/Sub** | **Kafka** | **RabbitMQ** |
| :--- | :--- | :--- | :--- |
| **메시지 영속성** | **없음** (Fire-and-Forget) | 있음 (Disk 저장) | 설정에 따라 가능 |
| **전송 속도** | **매우 빠름** (In-memory) | 빠름 (Batch 처리 시 유리) | 빠름 |
| **확장성** | 클러스터 구성 시 샤딩 필요 | 파티션 단위로 높은 확장성 | 클러스터링 지원 |
| **적합성** | **위치 정보처럼 유실되어도 되는 일회성 데이터** | 로그 수집, 데이터 분석 등 신뢰성이 중요한 경우 | 복잡한 라우팅이 필요한 경우 |

> **논의 포인트**: 
> * "위치 정보가 유실되면 안 되는 서비스(예: 구조 요청)라면?" (Kafka나 RabbitMQ 고려)
> * "Redis Pub/Sub의 CPU 부하가 너무 높다면?" (Erlang 기반의 RabbitMQ나 MQTT 브로커 고려)

### 1.3. 데이터 일관성 모델: Strong vs Eventual Consistency
| 구분 | **Strong Consistency (강한 일관성)** | **Eventual Consistency (결과적 일관성)** |
| :--- | :--- | :--- |
| **핵심 개념** | 데이터를 쓰자마자 누가 어디서 읽든 **항상 최신 데이터**를 보장함. | 지금 당장은 데이터가 다를 수 있지만, **시간이 지나면 결국 같아짐**을 보장함. |
| **특징** | 모든 복제본(Replica)에 쓰기가 완료될 때까지 기다림. | 쓰기 작업 후 즉시 응답하며, 복제는 비동기(Async)로 이루어짐. |
| **장점** | 데이터의 정확성과 신뢰성이 매우 높음. | 응답 속도가 빠르고(Low Latency), 시스템 가용성(Availability)이 높음. |
| **단점** | 응답 속도가 느리고, 네트워크 분할 시 가용성이 떨어질 수 있음. | 일시적으로 사용자에게 **과거 데이터(Stale Data)**가 보일 수 있음. |
| **대표 예시** | 은행 계좌 이체, 재고 관리 시스템 | SNS 좋아요 수, 유튜브 조회수, **주변 친구 위치** |

---

## 2. 면접 예상 질문 (Interview Q&A)
면접관이 꼬리를 물고 들어올 수 있는 질문들과 모범 답변 키워드입니다.

### Q1. "사용자가 이동하지 않고 가만히 있는데도 계속 위치 정보를 보내야 하나요?"
* **핵심 키워드**: `클라이언트 최적화`, `가속도 센서`, `배터리 절약`
* **답변 논리**:
    * 불필요한 서버 부하와 배터리 소모를 줄이기 위해, 클라이언트의 가속도 센서나 GPS 변화량을 감지하여 **일정 거리 이상 이동했을 때만** 위치 정보를 전송하도록 최적화해야 합니다.

### Q2. "Redis Pub/Sub 서버가 다운되면 어떻게 되나요? 복구 전략은?"
* **핵심 키워드**: `Service Discovery`, `Consistent Hashing`, `Re-subscription`
* **답변 논리**:
    * Redis Pub/Sub은 상태(구독 정보)를 가지므로, 서버 다운 시 해당 서버에 연결된 구독 정보가 사라집니다.
    * Service Discovery(ZooKeeper/Etcd)가 장애를 감지하고, 대체 서버를 할당합니다.
    * 웹소켓 서버는 이를 감지하고, 해시 링(Hash Ring)을 다시 계산하여 새로운 Pub/Sub 서버에 **재구독(Re-subscribe)** 요청을 보내야 합니다.

### Q3. "친구가 5,000명인 '인플루언서'가 위치를 이동하면 시스템에 어떤 영향이 있나요?"
* **핵심 키워드**: `Fan-out`, `부하 분산`, `비동기 처리`
* **답변 논리**:
    * 한 명의 위치 변경이 5,000명에게 전파되어야 하므로 순간적인 부하(Fan-out)가 발생합니다.
    * Redis Pub/Sub 클러스터가 잘 샤딩되어 있다면 부하가 분산되겠지만, 극단적인 경우 메시지 큐를 두어 전송 작업을 비동기로 처리하거나, 인플루언서의 위치 갱신 주기를 조정하는 등의 정책이 필요할 수 있습니다.

> Fan-out: 하나의 입력이 들어왔을 때, 이를 처리하기 위해 여러 곳으로 작업을 확산(복제)시키는 것

---

## 3. 심화 토론 주제 (Deep Dive Discussion)
단순한 구현을 넘어 시스템의 확장성과 엣지 케이스를 고민해봅니다.

### 주제 A: "주변 친구"가 아닌 "주변의 낯선 사람(Random User)" 찾기 기능 확장
* **상황**: 틴더(Tinder)나 당근마켓처럼 내 주변의 불특정 다수를 보여줘야 한다면?
* **접근법**:
    * 친구 관계 기반의 채널 구독(User ID Channel) 방식은 사용할 수 없습니다.
    * **Geohash 기반 채널 구독** 방식으로 변경해야 합니다.
    * 사용자는 자신의 위치에 해당하는 Geohash 격자 채널(및 인접 격자)을 구독하고, 자신의 위치 변경을 해당 격자 채널에 발행합니다.

### 주제 B: 웹소켓 서버의 오토스케일링(Auto-scaling)과 연결 유지
* **문제**: 웹소켓은 장기 연결(Long-lived Connection)이므로, 서버를 단순히 늘리거나 줄이기 어렵습니다. (기존 연결이 끊어짐)
* **해결책**:
    * **Graceful Shutdown**: 축소 대상 서버를 'Draining' 상태로 만들어 신규 연결을 막고, 기존 연결이 자연스럽게 끊어지거나 재연결되도록 유도합니다.
    * 클라이언트는 연결이 끊어지면 지수 백오프(Exponential Backoff) 전략으로 재연결을 시도해야 합니다.

> Draining 상태: 현재 처리 중인 작업은 마저 끝내게 하고, 새로운 작업은 받지 않는 상태

### 주제 C: 위치 정보의 보안과 프라이버시
* **문제**: 악의적인 사용자가 삼각측량 등을 통해 타인의 정확한 위치를 알아낼 수 있습니다.
* **해결책**:
    * 정확한 좌표 대신 **근사화된 위치(Fuzzing)**를 전송합니다.
    * 친구 간의 거리가 너무 가까워지면(예: 50m 이내) 정확한 거리를 표시하지 않고 "매우 가까움"으로만 표시합니다.

---

## 4. 추가 학습 추천
* **MQTT 프로토콜**: IoT 및 모바일 환경에서 경량 메시징을 위해 많이 사용되는 프로토콜. (Redis Pub/Sub의 대안)
* **Erlang/Elixir**: WhatsApp, Discord 등이 수억 명의 동시 접속(웹소켓)을 처리하기 위해 선택한 언어와 런타임(BEAM VM).
* **Consistent Hashing (안정 해시)**: 분산 시스템에서 노드 추가/삭제 시 데이터 이동을 최소화하는 알고리즘.
