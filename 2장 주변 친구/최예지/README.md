# (2) 주변 친구

## 1단계: 문제 이해 및 설계 범위 확정

### 기능요구사항

- **주변친구 조회** : 사용자는 주변 모바일로 친구의 정보(친구와의 거리, 마지막 갱신시간)를 확인할 수 있다.
- **친구목록 갱신**: n초에 한 번 갱신되어야한다.

### 비기능 요구사항

- 낮은 지연 시간
- 안정성: 때때로 일부 데이터 유실 ok
- 결과적 일관성: 원본-복제본과의 시간 차 인정

### 개략적 규모 추정

- 위치정보 갱신주기: 30초
- DAU = 1억
- 동시 접속자 수 = DAU*0.1 = 1000만
- **위치 정보 갱신 QPS = 1000만 / 30 =~ 334,000**

---

- 주변친구: 5마일(8km) 반경 이내 친구
- 사용자 당 평균 친구의 수 : 400
- 페이지 당 20명의 주변 친구 표시

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 개략적 설계안

- 이론적으론 순수한 P2P도 가능하나 모바일 단말은 변수가 많아 **공용 백엔드**를 사용
    
    ![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2F471f6273-a40b-4bf3-8e99-a0a7ab655639%2F5a33acea-04c7-4ae8-a5de-ff90d99673d8.png/size/w=1310?exp=1770295783&sig=DpvK2PSmDBsBQWtc-xD4zBjMemU2ePgZY669eR8Kk3Y&id=2fcbe4ca-d9d2-8007-9309-ed28422fb585&table=block)
    
- 공용백엔드의 역할
    - 모든 활성 상태 사용자의 위치 변화 내역 수신
    - ⇒ 수신 마다 해당 사용자의 모든 활성 상태 친구를 찾아 단말로 변경내용 전송
    - 사용자 간 거리가 특정 임계치를 넘으면 전송x
    - 단점: 큰 큐모의 서버 부하를 감당하기 어려움

### 설계안

![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2F14eea29c-b9d7-41d0-a4bf-63fca1772cfe%2Fimage.png/size/w=1360?exp=1770295913&sig=pnRMAFjNETlAu1e-J4JhxaESZCzHrzgDqMFdph5vrFs&id=2fcbe4ca-d9d2-80bd-a03a-c064e05501d0&table=block)

- 로드밸런서
    - RESTful API 서버 및 양방향 유상태(stateful) 웹소켓 서버 앞단에 위치. 트래픽들을 배분하는 역할.
- RESTful API서버
    - 무상태(stateless) API 서버의 클러스터. 통상적인 요청/응답 트래픽을 처리.
    - 친구 추가/삭제, 사용자 정보 갱신등의 부가적인 작업 처리.
- 웹소켓 서버
    - 친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 유상태 서버 클러스터
    - 검색 반경 내 친구 위치가 변경 ⇒ 웹소켓 서버 연결을 통해 클라이언트로 전송
    - 클라이언트의 초기화(활성화 되어있는 주변 친구 위치 전송) 담당
- 레디스 위치 정보 캐시
    - 활성 상태 사용자의 가장 최근 위치 정보
    - TTL (위치 정보 갱신 시 갱신. 만료되면 비활성화 처리)
- 사용자 데이터베이스
    - 사용자 데이터, 사용자 친구 관계 정보 등 저장
- 위치 이동 이력 데이터베이스
    - 사용자 위치 변동 이력을 보관 (부가 기능에 사용 가능)
- 레디스 펍/섭 서버
    
    ![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2F472013ed-9e6a-4ce5-95b3-894128254336%2Fimage.png/size/w=1310?exp=1770295941&sig=Z-hJWUP__ZJSRBEgZcAXJkiomjOzi0NUG1tbo8eoatY&id=2fcbe4ca-d9d2-80af-8953-dc846d9ea83c&table=block)
    
    - 초경량 메시지 버스
    - 웹 소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트 > 펍/섭 채널 > 구독자의 웹소켓 연결 핸들러 호출. (둘의 거리가 검색 반경 이내면 위치, 갱신시각을 웹소켓을 통해 구독자의 클라이언트 맵으로 전송)
- 주기적 위치 갱신
    1.  클라이언트 > [위치 정보] > 로드밸런서
    2. 로드밸런서 > [위치 정보] > 웹소켓 서버
    
    <하단 병렬 수행>
    
    1. 웹소켓 서버 > [위치 정보] > 위치 이동 이력 데이터베이스에 저장 
    2. 웹소켓 서버 > [위치 정보] > 위치정보 캐시에 저장
    웹소켓 서버 > [위치 정보] > 웹소켓 연결 핸들러에 저장 (이후 거리 계산에 사용)
    3. 웹소켓 서버 > [위치 정보] > 레디스 펍/섭 사용자 채널에 발행
    4. 레디스 펍/섭 채널 > [위치 정보] > 구독자(친구의 웹소켓 이벤트 핸들러)에 브로드캐스트
    5. 구독자의 웹소켓 서버: 발행자-구독자 간의 거리 계산 (with 웹소켓 연결 핸들러)
    6. 발행자-구독자 간 거리 ≤ 검색 반경 ⇒
    구독자 웹 소켓 > [위치/발생 시간 타임스탬프] > 구독자 클라이언트 앱
- 레디스 펍/섭 흐름

![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2F682dea62-3790-4334-97e7-8f13cae157a1%2Fimage.png/size/w=1360?exp=1770295958&sig=T3ElkT4WZH9oygrSaFkjMp7mU9R6dbhrn7ty0fDcPOA&id=2fdbe4ca-d9d2-80a1-a060-d88b2861a7fe&table=block)

### API 설계

- 웹소켓
    1. [서버 API] 주기적인 위치 정보 갱신
        
        REQUEST: 위도, 경도, 시각 정보
        
        RESPONSE: -
        
    2. [클라이언트 API] 클라이언트가 갱신 된 친구 위치를 수신하는 API
        
        전송 데이터: 친구 위치 데이터, 변경 시각(타임스탬프)
        
    3. [서버 API] 웹소켓 초기화 API
        
        REQUEST: 위도, 경도, 시각 정보
        
        RESPONSE: 사용자의 친구들의 위치데이터
        
    4. [클라이언트 API] 새친구 구독 API
        
        REQUEST: 친구 ID
        
        RESPONSE: 가장 최근 위도, 경도, 시각 정보
        
    5. [클라이언트 API] 구독 해지 API
        
        REQUEST: 친구 ID
        
        RESPONSE: -
        
- HTTP
    - 친구 추가/삭제/사용자 정보 갱신

### 데이터 모델

- 위치정보 캐시
    - 레디스 캐시
        
        
        | 키 | 값 |
        | --- | --- |
        | 사용자 ID | 위도, 경도, 시각 |
        - 사용자의 위치정보는 덧씌워지며, 영속성을 보장할 필요x, 장애 발생 시 다른 캐시가 warmed up될 때 까지의 손실은 수용 가능
        - 장점: 빠른 연산
- 위치 이동 이력 데이터베이스
    
    
    | user_id | latitude | longitude | timestamp |
    | --- | --- | --- | --- |

## 3단계: 상세 설계

### 중요 구성요소별 규모 확장성

- API 서버
    - RESTful API 서버 (무상태) 서버의 자동 규모 확장 방식 (오토스케일 등)
- 웹소켓 서버
    - 규모 확장: 편리
    - 서버 제거 시 유상태 서버이므로 주의 필요
        1. 노드상태: 연결 종료 중(draining) 으로 변경
        2. 모든 연결 종료 후 서버 제거
    - 새로운 버전 어플리케이션 설치 시에도 유의 필요.
    - 좋은 로드밸런서 중요
- 클라이언트 초기화
    
    웹소켓 연결 초기화 시 웹소켓 연결 핸들러의 수행
    
    1. 위치 정보 캐시에 보관 된 사용자 위치 갱신
    2. 연결 핸들러 내의 변수에 위치정보 저장
    3. 사용자 DB 내의 친구 정보 조회
    4. 위치 정보 캐시의 친구 위치 일괄 조회
    5. 캐시에서 조회한 친구와 사용자 간의 거리 계산
    ⇒ 결과 값이 검색 반경 이내면 친구의 정보를 클라이언트로 반환
    6. 각 친구의 레디스 펍/섭 채널 구독
    7. 사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 친구에게 전송
- 사용자 데이터 베이스
    - 사용자 상세 정보
        - 사용자ID|사용자명|프로파일 이미지URL …
    - 친구 관계 데이터
    - ⇒ 사용자 ID 기준으로 샤딩 (수평적 확장)
- 위치 정보 캐시
    - 위치정보
    - TTL
        - 위치정보 갱신 시 초기화
        - 만료 되면 삭제 (위치 비활성화)
    - ⇒ 사용자 ID 기준으로 샤딩
- 레디스 펍/섭 서버
    - 위치 변경 메시지의 라우팅 계층
    - 채널이 생성 된 이후에 사용되지 않으면 (오프라인 사용자) CPU 사용 x
    - 구독자 관계를 추적하기 위한 해시 테이블, 연결 리스트가 필요 (소량의 메모리 사용)
    - 구독 관계 설정 후 친구의 상태는 판별x.
    - 모든 채널은 독립적
- 분산 레디스 펍/섭 클러스터
    - 메세지 발행 사용자 ID 기준으로 샤딩
    - 서비스 탐색 소프트웨어: 설정 데이터를 보관하기 위한 소규모 키-값 저장소
        - 해시 링
            
            ![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2Ffeba3ad0-dca3-4ac8-8292-ea0ae8df5aa2%2Fimage.png/size/w=1200?exp=1770295977&sig=08HtLOpiKz6TxwOne116H-N9kj-oGrAnpeh9bm--Gbk&id=2fdbe4ca-d9d2-80b1-ba80-d2abb33afb70&table=block)
            
            - 키: /config/pub_sub_ring
            - 값: [”p_1”, “p_2”, “p_3”, “p_4]
            - 웹소켓 서버는 해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버 선정
                - 해시 링은 서비스 탐색 컴포넌트에 있으나 사본을 웹소켓 서버에 캐시해 효율을 높이는 방법도 고려 가능
- 레디스 펍/섭 서버 클러스터 규모 확장 고려사항
    - 레디스 펍/섭 서버 클러스터의 속성
        1. 펍/섭 채널에 전송되는 메시지는 모든 구독자에게 전송되면 삭제 (메모리, 디스크에 보관x)
            - 펍/섭 채널을 통해 처리 되는 데이터는 무상태.
        2. 채널에 대한 상태 정보 보관. (ex 채널의 구독자 목록)
            - 특정 채널을 담당하던 펍/섭 서버를 교체 혹은 제거 시 ⇒ 채널을 다른 서버로 이동 ⇒ 모든 구독자에게 알림
            - 해당 관점에서 펍/섭은 **유상태 서버**
    - 유상태 서버는 오버 프로저닝 하는게 보통
        - 펍/섭 서버 교체 혹은 제거 시 ⇒ 수 많은 재구독 요청 발생
        - 다른 처리에 영향이 오지 않게 교체/제거는 시스템 부하가 적은 시간에 시행할 필요가 있음
    - 클러스터 크기 조정 방법
        1. 새로운 링 크기 계산.
        2. 해시 링의 키에 매달린 값을 새로운 내용으로 갱신
        3. 대시보드를 모니터링: 웹소켓 클러스터의 CPU 사용량이 어느정도 튀어야 함
- 운영 고려사항
    - 레디스 펍/섭 서버 자체를 채널의 대규모 이동 사태 x 교체되는 서버의 채널만 수정
    
    ![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2F8f609d4b-fc4d-4f0e-8135-b39244b46b27%2Fimage.png/size/w=1310?exp=1770296005&sig=vqDtZULTIhiOBroCFxqWwp1PDEbEWzPbXfdR-TFq2zo&id=2fdbe4ca-d9d2-8047-a558-e4ea05bafcb4&table=block)
    
    - 교체 후 모든 웹소켓 서버에 통지. 각 웹소켓 서버는 새 펍/섭 채널을 다시 구독
- 친구 추가/삭제
    - 추가 ⇒ (콜백) 클라이언트에 연결 된 웹소켓 서버 연결 핸들러에게 통지 ⇒ 새 친구의 레디스 펍/섭 서버 구독
    - 삭제 ⇒ (콜백) 클라이언트에 연결 된 웹소켓 서버 연결 핸들러에게 통지 ⇒ 삭제 친구의 레디스 펍/섭 구독 취소
    
    +) 추가: 동일 방식으로 위치 정보 전송 허가/취소 구현 가능
    
- 친구가 많은 사용자
    - 최대로 맺을 수 있는 양방향 친구의 수에 상한이 있다고 가정.
    - 클러스터내의 웹소켓  서버가 나누어 부하를 처리하므로  큰 부하는 x
- 주변의 임의 사용자
    - 위치 정보 공유에 동의한 주변 사용자를 무작위 표기
    - 방법: 지오해시에 따라 구축 된 펍/섭 채널 풀을 생성
    
    ![image.png](https://img.notionusercontent.com/s3/prod-files-secure%2F594418fe-2b8a-40ce-8d83-fb1b120f4b8f%2F2a381595-624c-43e8-85d4-b3fdc9fcfa6a%2Fimage.png/size/w=1310?exp=1770296023&sig=G4LcFDgha2gMVSq23EN8vmvis7yfaWg1ypQD1i0bFEs&id=2fdbe4ca-d9d2-8004-8285-c6472b3d49be&table=block)
    
- 레디스 펍/섭 외의 대안
    - 얼랭(Erlang)
        - 고도로 분산된 병령 애플리케이션을 위해 고안 된 프로그래밍 언어 및 런타임 환경
        - 경량 프로세스 (최소 300byte 메모리, 활동이 없을 시 CPU 자원소모x)
        - 사용자가 적음…
        - 설계안에 사용 시
            - 웹소켓 서비스 → 얼랭
            - 레디스 펍/섭 클러스터 → 얼랭 애플리케이션
            - 각 사용자 → 얼랭 프로세스
            - 구독 관계 → 얼랭/OTP의 구독 기능 내장

---

## 개인 정리

### 무상태(stateless) vs 유상태(stateful)

1. 핵심 차이
- 무상태: 서버가 클라이언트의 이전 상태를 **기억하지 않음**.
- 유상태: 서버가 클라이언트의 이전 상태를 기억하고 유지함.
1. 동작 방식
- 무상태:
    - 모든 요청이 필요한 정보를 전부 들고 옴 (토큰, 파라미터 등).
    - 각 요청은 서로 완전히 독립적.
- 유상태:
    - 로그인 등으로 만든 세션을 서버가 저장.
    - 이후 요청은 세션 ID만 보내고, 서버는 저장된 상태를 보고 처리.
1. 특징 비교

| **구분** | **무상태 (Stateless)** | **유상태 (Stateful)** |
| --- | --- | --- |
| 상태 저장 | 서버에 없음, 요청 안에 모두 포함 | 서버 세션/컨텍스트에 저장 |
| 요청 관계 | 매 요청 독립 | 이전 요청 상태에 의존 |
| 확장성 | 서버 늘리고 줄이기 쉬움 | 세션 공유·스티키 필요 |
| 장애 대응 | 한 서버 죽어도 다른 서버로 바로 대체 | 세션 가진 서버 죽으면 복잡 |
| 쓰임새 | REST API, 마이크로서비스 | 실시간 게임, 채팅, 스트리밍 등 |
1. 비유
- 무상태: 패스트푸드점 – 주문표에 전부 적어서 줄 때마다 새 주문으로 처리.
- 유상태: 코스 요리 식당 – 손님이 몇 코스까지 먹었는지 서버가 계속 기억.
