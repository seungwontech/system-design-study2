# 1장: 근접성 서비스 설계

**설계의 트레이드오프, 면접 질문, 심화 토론**을 위주로 진행하기 위한 정리 자료입니다.

---

## 1. 핵심 트레이드오프 및 설계 논의 (Trade-offs)
설계 선택지 사이의 장단점을 비교하고, 상황에 맞는 최적의 선택을 논의합니다.

### 1.1. 공간 인덱스 방식 비교: Geohash vs Quadtree vs S2
| 특성 | **Geohash** | **Quadtree** | **Google S2** |
| :--- | :--- | :--- | :--- |
| **구현 난이도** | **낮음** (문자열/정수 Prefix 매칭) | **중간/높음** (트리 구조 직접 구현 필요) | **높음** (라이브러리 의존, 수학적 이해 필요) |
| **저장소 호환성** | 일반 RDBMS, KV Store(Redis) 등 어디든 사용 가능 | 메모리 기반이 유리하며, DB 저장 시 별도 로직 필요 | 주로 인메모리나 특수 라이브러리 필요 |
| **검색 정밀도** | 격자 크기가 고정적, 경계선 문제(Boundary Issue) 존재 | 데이터 밀도에 따라 격자 크기 동적 조절 가능 | 힐베르트 곡선 사용으로 공간 인접성 우수 |
| **갱신 비용** | **저렴** (단순 삭제/삽입) | **비쌈** (트리 재구성/Rebalancing 발생 가능) | 중간 |
| **동시성 제어** | 데이터베이스의 Row-level Lock 위임 가능 | 트리 노드별 Lock 관리 필요 (구현 복잡) | 라이브러리 특성에 따름 |

> **논의 포인트**: 
> * "우리 팀이 당장 다음 달까지 MVP를 내야 한다면 무엇을 선택할까?" (Geohash 유력)
> * "전 세계적인 규모의 정밀한 지도 서비스를 만든다면?" (S2 유력)

### 1.2. 정적 데이터 vs 동적 데이터 처리
* **사업장 정보 (정적)**:
    * 읽기 압도적, 쓰기 적음.
    * **전략**: RDBMS + 캐시(Redis) + Geohash/Quadtree.
    * 데이터 일관성: Eventual Consistency 허용 (다음 날 반영되어도 OK).
* **라이더/택시 위치 (동적)**:
    * 쓰기 매우 빈번 (수초마다 갱신).
    * **전략**: Redis (Geospatial) 등 인메모리 저장소 필수. 영속성보다는 속도.
    * 데이터 일관성: 즉시성 중요, 과거 데이터는 가치 하락.

> * Strong Consistency (강한 일관성)
>   * 데이터를 쓰자마자 누가 어디서 읽든 항상 최신 데이터를 보장
>   * 예: 은행 계좌 이체 (내 통장에서 돈이 빠져나갔으면, 즉시 잔액이 줄어든 것으로 보여야 함)
>   * 단점: 모든 노드에 데이터가 복제될 때까지 기다려야 하므로 속도가 느리고 가용성이 떨어질 수 있음
> * Eventual Consistency (결과적 일관성)
>   * 데이터를 썼을 때, 다른 노드에 전파되기까지 **약간의 지연(Delay)**이 있을 수 있음
>   * 그 사이에는 사용자가 **과거의 데이터(Stale Data)**를 볼 수도 있음
>   * 하지만 시간이 지나면(Eventually) 모든 노드가 동기화되어 같은 데이터를 갖게 됨
>   * 예: SNS 좋아요 수, 유튜브 조회수, 주변 친구 위치
>   * 장점: 데이터 동기화를 기다리지 않고 응답하므로 속도가 빠르고 시스템 가용성이 높음

---

## 2. 면접 예상 질문 (Interview Q&A)
면접관이 꼬리를 물고 들어올 수 있는 질문들과 모범 답변 키워드입니다.

### Q1. "사용자가 지도를 확대/축소(Zoom In/Out)할 때 시스템은 어떻게 대응하나요?"
* **핵심 키워드**: `Geohash 길이 조절`, `검색 반경(Radius) 변경`, `클러스터링(Clustering)`
* **답변 논리**:
    1. 줌 레벨에 매핑되는 Geohash 길이(정밀도)를 정의해 둡니다. (예: 시 단위 -> 4자리, 동 단위 -> 6자리)
    2. 줌 아웃(광역 뷰) 시에는 너무 많은 마커를 보여주면 클라이언트 성능이 저하되므로, 서버나 클라이언트에서 **클러스터링**(여러 마커를 하나로 뭉침) 처리를 해야 합니다.

### Q2. "강남역이나 타임스퀘어 같이 사람이 엄청 몰리는 핫스팟(Hotspot)은 어떻게 처리하나요?"
* **핵심 키워드**: `동적 격자 분할(Quadtree)`, `샤딩(Sharding)`, `Read Replica`
* **답변 논리**:
    1. **Quadtree**를 쓴다면 해당 지역만 트리를 깊게 쪼개서 격자당 사업장 수를 유지합니다.
    2. **Geohash**를 쓴다면 특정 해시값에 트래픽이 몰리므로, 해당 해시를 담당하는 파티션을 분리하거나(Sharding), 읽기 전용 복제본(Read Replica)을 늘려 부하를 분산합니다.

### Q3. "RDBMS에서 단순히 `lat`, `lon` 컬럼에 인덱스를 걸고 조회하면 왜 느린가요?"
* **핵심 키워드**: `교집합(Intersection) 비효율`, `2차원 데이터의 1차원 변환`
* **답변 논리**:
    * `lat` 범위 검색 결과와 `lon` 범위 검색 결과 각각은 매우 많을 수 있습니다.
    * DB 엔진이 두 거대한 집합의 교집합을 구하는 과정에서 성능이 떨어집니다.
    * 따라서 두 값을 하나로 합친(Geohash 등) 컬럼을 만들어 **단일 인덱스**를 타게 하는 것이 공간 인덱싱의 핵심 원리입니다.

---

## 3. 심화 토론 주제 (Deep Dive Discussion)
단순한 구현을 넘어 시스템의 확장성과 엣지 케이스를 고민해봅니다.

### 주제 A: 경로 기반 검색 (Path-based Search)
* **상황**: "내 주변"이 아니라 "서울에서 부산까지 가는 **경로 주변**의 주유소를 찾아달라"는 요구사항이 들어온다면?
* **접근법**:
    1. 경로(LineString)를 따라 일정 반경(Buffer)을 가진 다각형(Polygon)을 생성.
    2. 해당 다각형과 겹치는 Geohash 격자들을 계산하여 1차 필터링.
    3. 필터링된 주유소들에 대해 정확한 거리/경로 이탈 계산 수행.

### 주제 B: 위치 정보의 캐싱 전략 (Caching Strategy)
* **문제**: 사용자 위치(위도/경도)는 소수점 단위로 미세하게 계속 변합니다. 좌표를 키(Key)로 캐싱하면 적중률(Hit Rate)이 0에 수렴합니다.
* **해결책**:
    * 정확한 좌표 대신 **사용자가 속한 Geohash 격자**를 키로 사용하여 캐싱합니다.
    * "내 주변 정보"는 내가 조금 움직여도 같은 격자 내라면 결과가 같거나 비슷하기 때문입니다.

### 주제 C: 개인정보 보호와 위치 데이터 (Privacy)
* **문제**: 사용자의 정확한 위치를 서버에 저장하거나 로그로 남기는 것은 보안 리스크가 큽니다.
* **해결책**:
    * **Fuzzing/Blurring**: 위치를 저장할 때 랜덤한 오차를 더하거나, 정밀도를 낮춰서(Geohash 뒷자리 절삭) 저장.
    * 일정 시간이 지나면 파기하거나 익명화 처리.

---

## (참고) 실무 기술 스택 및 확장 개념
* **Redis GEO**: `GEOADD`, `GEORADIUS` (Geohash 기반, 실무에서 가장 빠르고 간편)
* **PostGIS**: RDBMS 표준 공간 확장 (R-Tree 기반, 복잡한 기하 연산 가능)
* **Uber H3**: 육각형(Hexagon) 인덱스. 반경 탐색 시 왜곡이 적고 이웃 간 거리가 균일함.
