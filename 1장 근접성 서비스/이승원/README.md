## 근접성 서비스

- 음식점 호텔 등 내 위치 주변의 사업장을 찾는 시스템을 설계하는 방법입니다.

### 핵심

- `수많은 위치 데이터 중에서 내 주변의 데이터를 어떻게 빠르게 검색할까?`에 대한 해답을 찾은 과정입니다.

--- 

## 기능 요구사항

- 사용자의 위치와 검색 반경 정보에 매치되는 사업장 목록 반환해야 합니다.
- 사업장 소유주가 사업장 정보 추가, 삭제, 갱신할 수 있도록 하되,
  그 정보가 실시간으로 반영될 필요 없습니다.
- 고객은 사업장의 상세 정보를 살필 수 있어야 합니다.

## 비기능 요구사항

- 사용자는 주변 사업장으 신속히 검색해야 합니다.
- 사용자 위치는 민감한 정보이므로, 위치기반 서비스를 설계할때는   
  법안을 준수하도록 해야 합니다.
- 인구 밀집 지역에서 이용자 급증해도 감당할수 있도록 설계해야합니다.

---

## 핵심 문제

`SELECT * FROM places WHERE lat BETWEEN x1 AND x2 AND lon BETWEEN y1 AND y2;`  
DB에서 단순히 위도/경도를 where절로 비교하면 매우 느립니다.  
인덱스를 타더라도 2차원 데이터를 1차원 인덱스로 처리하는데 한계가 있습니다.  
이를 해결하기 위해 지리적 인덱싱 기법이 필요합니다.

---

## 지리적 인덱싱 기법

- 단순 SQL (WHERE lat BETWEEN...)은 속도가 느려 사용할 수 없습니다. 다음 중 하나를 선택합니다.

### 지오해시 (Geohash)

- 방법: 세계를 격자로 나누고 각 칸을 문자열로 인코딩.
- 장점: Redis나 DB 인덱스를 그대로 쓸 수 있어 구현이 매우 쉬움.

### 쿼드트리 (Quadtree)

- 방법: 데이터 밀도에 따라 격자를 4개씩 자식 노드로 분할하는 트리 구조.
- 장점: 인구 밀집 지역은 세밀하게, 한적한 곳은 크게 관리하여 메모리 효율적.

### 구글 S2 / PostGIS

- S2: 힐베르트 곡선을 이용해 정교한 영역 계산 가능 (구글 맵 사용).
- PostGIS: PostgreSQL 환경에서 별도 서버 구축 없이 위치 쿼리 가능.

--- 

핵심 동작 알고리즘
1. 격자 분할: 지도를 일정한 크기의 셀로 쪼갭니다.
2. 색인화: 각 사업장 위치를 계산해 해당되는 셀에 할당합니다.
3. 조회 및 필터링:
   - 사용자가 속한 셀 + 주변 8개의 셀을 함께 조회합니다.
   - 가져온 후보군들을 대상으로 실제 거리를 계산해 정렬 및 필터링하여 반환합ㄴ디ㅏ.

## 최적화 및 확장성 (Deep Dive)
- 캐싱: 지오해시(격자 ID)를 키로, 사업장 ID 목록을 값으로 캐싱하여 DB 부하를 줄입니다.  
- 샤딩: 사업장 수가 너무 많아지면 사업장 ID 기준으로 샤딩하거나, 지리적 영역(국가/도시)별로 서버를 분산합니다.    
- 복제(Replication): 읽기 부하가 높으므로 DB 및 캐시 서버를 다중화(Read Replicas)하여 대응합니다.