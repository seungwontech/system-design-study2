# 4장: 분산 메시지 큐 설계

**설계의 트레이드오프, 면접 질문, 심화 토론**을 위주로 진행하기 위한 정리 자료입니다.

---

## 1. 핵심 요약
* **목표**: 높은 가용성, 확장성, 내구성을 갖춘 분산 메시지 큐 설계 (Kafka와 유사)
* **핵심 컴포넌트**:
    * **Producer**: 메시지 발행 (Push)
    * **Broker**: 메시지 저장 및 전달 (Partition 단위 분산 저장, WAL 활용)
    * **Consumer**: 메시지 구독 (Pull)
    * **ZooKeeper/Etcd**: 메타데이터 관리 및 리더 선출
* **주요 특징**:
    * **Topic & Partition**: 확장성을 위한 데이터 분할
    * **Consumer Group**: 병렬 처리를 위한 소비자 그룹화
    * **Replication**: 데이터 유실 방지를 위한 복제 (Leader-Follower)
    * **WAL (Write-Ahead Log)**: 디스크 순차 쓰기를 통한 고성능 달성

---

## 2. 핵심 트레이드오프 및 설계 논의 (Trade-offs)
설계 선택지 사이의 장단점을 비교하고, 상황에 맞는 최적의 선택을 논의합니다.

### 2.1. 메시지 전달 방식: Push vs Pull
| 특성 | **Push 모델** (Broker -> Consumer) | **Pull 모델** (Consumer <- Broker) |
| :--- | :--- | :--- |
| **지연 시간 (Latency)** | **낮음** (실시간 전송) | 보통 (Polling 주기에 의존) |
| **흐름 제어 (Flow Control)** | 어려움 (Consumer가 압도될 수 있음) | **쉬움** (Consumer가 처리 가능한 만큼 가져감) |
| **일괄 처리 (Batching)** | 어려움 (개별 전송 위주) | **쉬움** (한 번에 여러 메시지 가져오기 가능) |
| **구현 복잡도** | Broker가 Consumer 상태 관리 필요 | Consumer가 자신의 Offset 관리 (Broker 단순화) |
| **적합성** | 실시간성이 매우 중요한 알림 시스템 | **대용량 데이터 처리 (Kafka 등)** |

> **논의 포인트**: 
> * "왜 Kafka는 Pull 모델을 선택했을까?" (대용량 배치 처리와 Consumer의 자율성 보장)
> * "Push 모델이 더 유리한 경우는?" (RabbitMQ, 실시간 채팅 등)

### 2.2. 데이터 저장 방식: DB vs WAL (File System)
| 방식 | **Database (RDBMS/NoSQL)** | **WAL (Write-Ahead Log)** |
| :--- | :--- | :--- |
| **구조** | B-Tree / LSM-Tree 등 복잡한 인덱싱 | **단순 파일 추가 (Append-only)** |
| **쓰기 성능** | 보통 (인덱스 갱신 오버헤드) | **매우 높음** (디스크 순차 쓰기) |
| **읽기 성능** | 랜덤 읽기에 유리 | **순차 읽기에 최적화** (Zero-Copy 활용 가능) |
| **기능** | 복잡한 쿼리, 필터링 가능 | 단순 Offset 기반 읽기만 가능 |
| **적합성** | 메시지 검색/수정이 필요한 경우 | **높은 처리량(Throughput)이 필요한 로그성 데이터** |

> **논의 포인트**: 
> * "디스크는 느리지 않나?" (순차 쓰기는 메모리만큼 빠를 수 있음 + OS Page Cache 활용)

### 2.3. 메시지 전송 시맨틱 (Delivery Semantics)
| 방식 | **At-most once (최대 한 번)** | **At-least once (최소 한 번)** | **Exactly once (정확히 한 번)** |
| :--- | :--- | :--- | :--- |
| **동작** | ACK 안 기다림 (Fire-and-forget) | ACK 받을 때까지 재전송 | 중복 제거 메커니즘 포함 |
| **데이터 유실** | **발생 가능** | 없음 | 없음 |
| **데이터 중복** | 없음 | **발생 가능** | 없음 |
| **성능** | **가장 빠름** | 보통 | 느림 (트랜잭션 비용 발생) |
| **적합성** | 로그 수집, IoT 센서 데이터 | **대부분의 일반적인 메시징** | 결제, 금융 시스템 |

---

## 3. 면접 예상 질문 (Interview Q&A)
면접관이 꼬리를 물고 들어올 수 있는 질문들과 모범 답변 키워드입니다.

### Q1. "Kafka가 RabbitMQ보다 빠른 이유는 무엇인가요?"
* **핵심 키워드**: `순차 쓰기(Sequential I/O)`, `Zero-Copy`, `배치 처리(Batching)`, `단순한 브로커`
* **답변 논리**:
    * Kafka는 디스크의 **순차 쓰기**를 적극 활용하여 디스크 I/O 병목을 줄입니다.
    * **Zero-Copy** 기술(sendfile 시스템 콜)을 사용하여 커널 영역에서 데이터를 바로 네트워크로 쏘아주어 CPU/메모리 복사 비용을 줄입니다.
    * 브로커가 메시지 상태(소비 여부)를 관리하지 않고, 단순히 파일에 쓰고 읽어주기만 하므로 부하가 적습니다.

### Q2. "Consumer Group은 왜 필요한가요?"
* **핵심 키워드**: `병렬 처리`, `확장성`, `파티션 할당`
* **답변 논리**:
    * 하나의 토픽을 여러 컨슈머가 나눠서 처리하여 **처리량(Throughput)**을 높이기 위함입니다.
    * 같은 그룹 내의 컨슈머들은 토픽의 **파티션**을 서로 겹치지 않게 나눠 갖습니다.
    * 이를 통해 메시지 순서 보장(파티션 단위)과 병렬 처리를 동시에 달성합니다.

### Q3. "메시지 순서는 어떻게 보장하나요?"
* **핵심 키워드**: `파티션 단위 순서 보장`, `파티셔닝 키`
* **답변 논리**:
    * 분산 시스템 전체에서 전역적 순서 보장은 매우 어렵고 비효율적입니다.
    * 대신 **파티션 내에서의 순서**만 보장합니다.
    * 순서가 중요한 메시지(예: 같은 주문의 결제->배송)는 **같은 키(Key)**를 사용하여 동일한 파티션으로 보내지도록 해야 합니다.

---

## 4. 심화 토론 주제 (Deep Dive Discussion)
단순한 구현을 넘어 시스템의 확장성과 엣지 케이스를 고민해봅니다.

### 주제 A: 리밸런싱(Rebalancing)의 부작용과 대처
* **문제**: 컨슈머가 추가되거나 죽었을 때 발생하는 리밸런싱(Stop-the-world) 동안 메시지 처리가 멈추는 현상.
* **해결책**:
    * **Static Membership**: 컨슈머가 재시작되어도 ID를 유지하여 불필요한 리밸런싱 방지.
    * **Incremental Cooperative Rebalancing**: 한 번에 모든 파티션을 뺏지 않고, 점진적으로 이동시켜 중단을 최소화.

### 주제 B: "정확히 한 번(Exactly-once)" 전송의 구현
* **문제**: 네트워크 장애 시 재전송으로 인한 중복 발생.
* **해결책**:
    * **Idempotent Producer**: 프로듀서에 PID와 시퀀스 번호를 부여하여 브로커가 중복을 걸러냄.
    * **Transactional Messaging**: 여러 파티션에 대한 쓰기를 하나의 트랜잭션으로 묶음 (Atomic Commit).

### 주제 C: 랙(Lag) 모니터링과 오토스케일링
* **문제**: 프로듀서가 메시지를 보내는 속도보다 컨슈머가 처리하는 속도가 느려지면 랙(Lag)이 쌓임.
* **해결책**:
    * Consumer Lag을 지표로 삼아 컨슈머 인스턴스를 자동으로 늘리는(HPA) 전략.
    * 파티션 개수도 함께 늘려야 컨슈머 확장의 효과를 볼 수 있음.

---

## 5. 추가 학습 추천
* **Zero-Copy (sendfile)**: Kafka 성능의 핵심인 OS 레벨 최적화 기법.
* **CAP 이론과 PACELC 이론**: 분산 시스템에서 일관성과 가용성의 트레이드오프.
* **Apache Pulsar**: Kafka의 단점(스케일링, 멀티테넌시 등)을 보완한 차세대 메시징 시스템 구조 비교.
