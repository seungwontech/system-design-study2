## 4장 분산 메시지 큐

### 1. 메시지 큐(Message Queue) 도입의 이점

- 결합도 완화(Decoupling): 컴포넌트 간의 강한 결합을 제거하여 각 서비스를 독립적으로 수정 및 운영할 수 있습니다.

- 규모 확장성(Scalability): 생산자(Producer)와 소비자(Consumer) 시스템 규모를 트래픽 부하에 따라 독립적으로 확장할 수 있습니다.

- 가용성 개선(Availability): 특정 컴포넌트에 장애가 발생해도 큐가 메시지를 보관하므로 시스템 전체의 안정성이 유지됩니다.

- 성능 개선(Performance): 비동기 통신을 통해 생산자는 응답을 기다리지 않고 작업을 계속할 수 있습니다.

### 2. 주요 개념 및 용어

- 토픽(Topic): 메시지를 주제별로 분리하는 단위입니다.

- 파티션(Partition): 토픽을 여러 서버에 분산하여 저장하는 단위로, 높은 확장성을 달성하는 핵심입니다.

- 브로커(Broker): 파티션을 유지하고 관리하는 서버입니다.

- 오프셋(Offset): 파티션 내에서 메시지의 위치를 나타내는 고유 번호입니다.

- 소비자 그룹(Consumer Group): 토픽의 메시지를 병렬로 소비하기 위해 협력하는 소비자들의 집합입니다.

### 3. 데이터 저장소 설계: DB vs WAL

- 메시지 큐는 빈번한 읽기/쓰기가 발생하므로 일반적인 DB보다는 WAL(Write-Ahead Log) 방식이 권장됩니다.

- DB 사용 시의 한계: 대규모의 빈번한 읽기/쓰기를 동시에 처리하는 DB 설계는 복잡하고 오버헤드가 큽니다.

- WAL (쓰기 우선 로그): 단순 파일 끝에 메시지를 추가하는(Append-only) 구조입니다.

- 순차 I/O 활용: 디스크는 무작위 접근보다 순차 접근 시 수백 MB/sec의 높은 성능을 발휘합니다.

- OS 캐시 활용: 운영체제의 디스크 캐시 기능을 적극 활용하여 성능을 극대화합니다.

### 4. 성능 최적화 전략

- 일괄 처리(Batching): 생산자는 메시지를 버퍼에 모아 전송하고, 소비자도 묶음 단위로 가져와 네트워크 비용을 줄입니다.

- Pull 모델의 장점: 대부분의 현대적 MQ(예: Kafka)는 소비자가 자신의 처리 속도에 맞춰 데이터를 가져오는 Pull 모델을 채택합니다.

- 부하 조절(Flow Control)이 쉽고 일괄 처리에 유리합니다.

- 데이터가 없을 때 발생하는 자원 낭비는 **롱 폴링(Long Polling)** 으로 해결합니다.

### 5. 고가용성 및 신뢰성

- 복제(Replication): 데이터를 여러 브로커에 복제하여 장애 시에도 소실되지 않도록 합니다.

- ISR (In-Sync Replicas): 리더와 동기화된 사본들의 집합으로, 성능과 영속성 사이의 타협점 역할을 합니다.

- 전달 보장 설정 (Producer ACKs):

- ACK=all: 모든 ISR이 메시지를 수신해야 완료 (가장 안전하지만 느림).

- ACK=1: 리더만 메시지를 저장하면 완료 (보통 수준의 성능과 안전성).

- ACK=0: 응답을 기다리지 않고 계속 전송 (가장 빠르지만 데이터 유실 가능성 있음).

### 6. 소비자 재조정(Rebalancing)

- 새로운 소비자가 추가되거나 기존 소비자가 그룹을 떠날 때, 파티션 소유권을 다시 분배하는 프로세스입니다.

- 코디네이터(Coordinator): 브로커 중 하나가 코디네이터 역할을 맡아 소비자의 **하트비트(Heartbeat)** 를 모니터링하고 재조정을 제어합니다.

### 7. 조정 및 상태 관리

- 메타데이터 저장소: 토픽 설정, 파티션 수, 사본 배치 정보 등을 저장하며 높은 일관성을 요구합니다.

- Zookeeper: 브로커 클러스터의 리더 선출 및 메타데이터 관리를 담당하는 필수 컴포넌트로 널리 사용됩니다.

--- 

## 면접 대비 핵심 질문 리스트

### Q1. "왜 DB 대신 로그(WAL) 방식을 써서 성능을 높이나요?"

- 한 줄 요약: 디스크에 **'순차적으로 적는 것'** 이 훨씬 빠르기 때문입니다.

- 설명: DB는 데이터를 저장할 때 위치를 찾느라 디스크 헤드가 바쁘게 움직여야 하지만(랜덤 I/O),  
  로그 방식은 그냥 파일 끝에 쭉 이어 붙이기만 하면 됩니다(순차 I/O).

- 비유: 책장 여기저기 빈 곳을 찾아 책을 꽂는 것보다, 그냥 바닥에 순서대로 쌓아두는 게 훨씬 빠른 것과 같습니다.

- 보너스: 이 방식은 운영체제(OS)가 미리 데이터를 읽어두기도 편해서 메모리처럼 빠르게 작동합니다.

### Q2. "Push(밀어주기)보다 Pull(당겨오기) 방식이 왜 더 좋나요?"

- 한 줄 요약: 소비자가 '자기가 먹을 수 있는 만큼만' 가져올 수 있기 때문입니다.

- 설명: 브로커가 억지로 밀어넣으면(Push) 소비자가 감당 못 해 서버가 터질 수 있습니다.   
  하지만 직접 가져가면(Pull) 자기 속도에 맞춰 조절할 수 있습니다.

- 장점: 한 번에 여러 개를 묶어서(Batching) 가져오기도 편해서 네트워크 비용도 아낄 수 있고,   
  브로커가 소비자의 상태를 일일이 신경 안 써도 되니 구조가 단순해집니다.

### Q3. "Producer ACK 설정(all vs 1)의 차이와 선택 기준은?"

- 한 줄 요약: **'속도'** 를 택할지, **'안전'** 을 택할지의 차이입니다.

- ack=1 (속도 우선): 대장(Leader) 브로커 한 명만 받았다고 하면 바로 다음 작업으로 넘어갑니다.  
  빠르지만, 대장이 바로 죽으면 데이터가 사라질 수 있습니다.

- ack=all (안전 우선): 모든 복제본(Follower)들까지 다 받았는지 확인합니다. 느리지만 데이터가 절대 안 사라집니다.

- 활용: 결제 정보처럼 돈과 관련된 건 all, 단순 로그나 조회수처럼 조금 유실되어도 큰 문제 없는 건 1을 씁니다.